
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
\documentclass{article}
\usepackage{amsmath}
\usepackage {latexsym}
\usepackage{algorithm}
\usepackage{algorithmic}


\author{Xia Ding}
\title{\textbf{Introduction To Algorithm}\\Third Edition\\\textbf{Answer}}

\begin{document}
\maketitle
\section*{24.1}
\subsection*{24.1--1}
It's easy to do it by yourself.

\subsection*{24.1--2}
\begin{description}
\item[Necessity ] According to \textit{\textbf{Lemma 24.2}}, if there is a
path from s to v, then BELLMAN-FORD will terminates with $v.d = \delta(s, v) <\infty$.
\item[Sufficiency ] Because $v.d = \infty$ for all $v\in{V}$ except $s$ at the
begin, if algorithm terminates with $v.d < \infty$, there must be a node $v_1$
with $v_1.d < \infty$ incident with $v$. And so on, there must be a node $v_n$
incident with $s$ because $s$ it's the only node whose $d < \infty$ at the begin. So there is a path between $s$ and $v$.
\end{description}

\subsection*{24.1--3}
If the greatest number of edges on any shortest path from the source is $m$, then the path-relaxation property tells us that after $m$ iterations of BELLMAN-FORD, every vertex $v$ has achieved its shortest-path weight in $v.d$. By the Upper-bound property, after $m$ iterations, no $d$ values will ever change. Therefor, no $d$ values will change in the $(m + 1)$st iteration. Because we don't know $m$ in advance, we cannot make the algorithm iterate exactly $m$ times and then terminate. But if we just make the algorithm stop when nothing changes any more, it will stop after $m + 1$ iterations.\\
Algorithm 1 and 2.\\
The test for a negative-weight cycle has been removed above, because this version of the algorithm will never get out of the \textbf{while} loop unless all $d$ values stop changing.
\begin{algorithm}
  \caption{FORD-(M+1)($G, w, s$)}
  \begin{algorithmic}[1]
    \STATE $changes =$ TRUE
    \WHILE {$changes ==$ TRUE}
    \STATE $changes =$ FALSE
    \FORALL {edge $(u, v)\in{G.E}$}
    \STATE RELAX-M$(u, v, w)$
    \ENDFOR
    \ENDWHILE
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{RELAX-M($u, v, w$)}
  \begin{algorithmic}[1]
    \IF {$v.d > u.d + w(u, v)$}
    \STATE $v.d = u.d + w(u, v)$
    \STATE $v.\pi = u$
    \STATE $changes =$ TRUE
    \ENDIF
  \end{algorithmic}
\end{algorithm}

\subsection*{24.1--4}
TODO

\subsection*{24.1--5}
TODO

\subsection*{24.1--6}
Algorithm ..\\
In the check stage of Bellman-Ford algorithm, if $v.d > u.d + w(u, v)$, there must be a negative weight cycle $<v, v_1, v_2\ldots{},v_n, u>$, we can use $u.\pi$ to get the node before $u$ and so on until we reach the $v$, then we get the nodes in that cycle.
\begin{algorithm}
  \caption{NEGATIVE-CYCLE(G)}
  \begin{algorithmic}[1]
    \STATE $s =$ RANDOM-SELECT(G.V)
    \STATE INITIALIZE-SINGLE-SOURCE$(G, s)$
    \FOR {$i = 1$ \textbf{to} $|G.V| - 1$}
    \FORALL {edge$(u, v) \in{G.E}$}
    \STATE RELAX$(u, v, w)$
    \ENDFOR
    \ENDFOR
    \FORALL {edge$(u, v)\in{G.E}$}
    \IF {$v.d > u.d + w(u, v)$}
    \STATE $t = u$
    \WHILE {$t \ne v$}
    \STATE print$(t)$
    \STATE $t = t.\pi$
    \ENDWHILE
    \STATE print$(v)$
    \ENDIF
    \ENDFOR
  \end{algorithmic}
\end{algorithm}

\section*{24.2}
\subsection*{24.2--1}
It's easy to do by yourself.

\subsection*{24.2--2}
Because the last node if is reachable, it must be relaxed by some nodes
incident with it in $|V| - 1$ iterations. So all nodes have been relaxed.
It's correct.

\subsection*{24.2--3}
TODO

\subsection*{24.2--4}
TODO

\section*{24.3}
\subsection*{24.3--1}
It's easy to do by yourself.

\subsection*{24.3--2}
Let $V = {a, b, c, d}$, $E = {(a, b, 1), (b, c, -2), (c, b, 1), (b, d, 1)}$.
When we calculate the shortest path between from $a$ to $d$, after the
procedure, $b.d = 0$, producing incorrect answer.

\subsection*{24.3--3}
Yes, the algorithm still works. Let $u$ be the leftover vertex that doesn't
get extracted from the priority queue $Q$. If $u$ isn't reachable from $s$,
then $u.d = \delta(s, u) = \infty$. If $u$ is reachable from $s$, then there is a shortest path \mbox{$p = s\leadsto x \rightarrow u$}. When the node $x$ was extracted, $x.d = \delta(s, x)$ and then the edge $(x, u)$ was relaxed; thus,
$u.d = \delta(s, u)$.

\subsection*{24.3--4}
Algorithm ..\\
\begin{algorithm}
  \caption{\label{alg1} CHECK(G)}
  \begin{algorithmic}
    \FOR {$i = 1$ to $|G.V|$}
    \FORALL {$j$ in $G.Adj[i]$}
    \IF {$j.d > i.d + w(i, j)$}
    \RETURN \textbf{FALSE}
    \ENDIF
    \ENDFOR
    \ENDFOR
    \RETURN \textbf{TRUE}
  \end{algorithmic}
\end{algorithm}


\subsection*{24.3--5}
$V = {a, b, c, d}$, $E = {(a, d, 9), (a, c, 1), (c, d, 1), (d, b, 1)}$.

\subsection*{24.3--6}

\subsection*{24.3--7}
\subsection*{24.3--8}
\subsection*{24.3--9}
\subsection*{24.3--10}

\section*{24.4}
\subsection{24.4--1}
\subsection{24.4--2}
\subsection{24.4--3}
\subsection{24.4--4}
\subsection{24.4--5}
\subsection{24.4--6}
\subsection{24.4--7}
\subsection{24.4--8}
\subsection{24.4--9}
\subsection{24.4--10}
\subsection{24.4--11}
\subsection{24.4--12}

\section*{24.5}
\subsection{24.5--1}
\subsection{24.5--2}
\subsection{24.5--3}
\subsection{24.5--4}
\subsection{24.5--5}
\subsection{24.5--6}
\subsection{24.5--7}
\subsection{24.5--8}

\section*{Problems}
\subsection{24--1}
\subsection{24--2}
\subsection{24--3}
\subsection{24--4}
\subsection{24--5}
\subsection{24--6}

\end{document}